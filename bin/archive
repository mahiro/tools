#!/usr/bin/perl -w
use strict;
use FindBin;

BEGIN {
	my $local = "$FindBin::RealBin/$FindBin::RealScript.local";
	require $local if -f $local;
}

use Cwd qw(abs_path);
use Date::Parse;
use DateTime;
use DateTime::Format::Duration;
use File::Basename;
use File::Path;
use Getopt::Long;
use IO::Handle;
use POSIX;

sub parse_args {
	my $opt = {};

	GetOptions $opt, qw(
		directory=s path=s
		gmt mtime older=s
		exec=s
		force interactive verbose
		show help
	) or die $!;

	if ($opt->{help}) {
		my $cmd = basename($0);

		print <<END;
Usage: $cmd [OPTIONS] [FILES..]

Move the specified files (or files in the current directory if omitted) to an
archive directory, classifying the files by the date/time.

Options:
  -d ARCHIVE_DIR, -directory ARCHIVE_DIR
    Specify archive directory. Default = ./archives

  -p DATETIME, -path DATETIME
    Specify date/time format. Default = \%Y/\%m/\%d

  -g, -gmt
    Use GMT intead of local time.

  -m, -mtime
    Always use each file's mtime instead of trying to interpret the file name.

  -o TIMESPAN, -older TIMESPAN
    Only archive files older than the specified time span (or a specific time).

  -e COMMAND, -exec COMMAND
    Run COMMAND after each file is moved. Any occurrences of a pair of braces
    ('{}') will be replaced by the file, or if no {} pairs occur, the file name
    is appended at the end as an argument.

  -f, -force
    Skip the confirmation step at the beginning.

  -i, -interactive
    Confirm each file to move interactively.

  -v, -verbose
    Print each moved file.

  -s, -show
    Print the list of files to archive and exit.

  -h, -help
    Print help and exit.
END

		exit 1;
	}

	$opt->{older} = parse_timespan($opt->{older}) if defined $opt->{older};
	return wantarray ? ($opt, @ARGV) : $opt;
}

sub parse_timespan {
	my ($input) = @_;

	if ($input =~ /^\s*(\d+)\s*$/) {
		die "time unit must be provided: $input";
	} elsif ($input =~ /^\s*(\d+|\d*\.\d+)\s*(\w+)\s*$/) {
		my ($num, $unit) = ($1, lc($2));
		my $d;

		if ($unit =~ /^y((ea)?r)?s?$/) {
			$d = DateTime::Duration->new(years => $num);
		} elsif ($unit =~ /^mo(n(th)?)?s?$/) {
			$d = DateTime::Duration->new(months => $num);
		} elsif ($unit =~ /^w(ee)?k?s?$/) {
			$d = DateTime::Duration->new(weeks => $num);
		} elsif ($unit =~ /^da?y?s?$/) {
			$d = DateTime::Duration->new(days => $num);
		} elsif ($unit =~ /^h(ou)?r?s?$/) {
			$d = DateTime::Duration->new(hours => $num);
		} elsif ($unit =~ /^m(i(n(ute)?)?)?s?$/) {
			$d = DateTime::Duration->new(minutes => $num);
		} elsif ($unit =~ /^s(e(c(ond)?)?)?s?$/) {
			$d = DateTime::Duration->new(seconds => $num);
		} else {
			die "cannot parse time span: $input";
		}

		my $dt = DateTime->now;
		return $dt->subtract_duration($d)->epoch;
	} else {
		return str2time($input);
	}
}

sub should_move {
	my ($file, $dir) = @_;
	return 0 if !-e $file || basename($file) =~ /^\.\.?$/;
	return abs_path($file) !~ m{^$dir(/|$)};
}

sub make_time {
	my ($opt, $year, $month, $day, $hour, $minute, $second) = @_;
	
	if ($opt->{gmt}) {
		return DateTime->new(year => $year, month => $month, day => $day,
			hour => $hour, minute => $minute, second => $second, time_zone => 'GMT')->epoch;
	} else {
		return DateTime->new(year => $year, month => $month, day => $day,
			hour => $hour, minute => $minute, second => $second)->epoch;
	}
}

sub get_time {
	my ($opt, $file) = @_;

	unless ($opt->{mtime}) {
		my $base = basename($file);

		if ($base =~ /\b(\d{4})(\d{2})(\d{2})[\-\._]?(\d{2})(\d{2})(\d{2})\b/) {
			return make_time($opt, $1, $2, $3, $4, $5, $6);
		} elsif ($base =~ /\b(\d{4})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})\b/) {
			return make_time($opt, $1, $2, $3, $4, $5, $6);
		} elsif ($base =~ /\b(\d{4})(\d{2})(\d{2})\b/) {
			return make_time($opt, $1, $2, $3, 0, 0, 0);
		} elsif ($base =~ /\b(\d{4})[\-\._](\d{2})[\-\._](\d{2})\b/) {
			return make_time($opt, $1, $2, $3, 0, 0, 0);
		}
	}

	return ((stat $file)[9]);
}

sub move_file {
	my ($opt, $file, $time, $dir, $absdir, $path) = @_;

	my $dst = ($opt->{gmt} ?
			strftime($path, gmtime $time) :
			strftime($path, localtime $time));

	my $dst_dir = "$absdir/$dst";
	my $dst_file = "$dst_dir/".basename($file);

	if (-e $dst_file) {
		if ($opt->{interactive}) {
			print "$dst_file already exists. Overwrite? [y/N] ";
			STDOUT->flush;
			return if <STDIN> !~ /^y/i;
		} else {
			print STDERR "$dst_file: already exists\n";
			return;
		}
	}

	if ($opt->{interactive}) {
		print "$dst: $file: Archive? [y/N] ";
		STDOUT->flush;
		return if <STDIN> !~ /^y/i;
	}

	mkpath $dst_dir if !-d $dst_dir;

	print "mv $file $dst_file\n" if $opt->{verbose};
	rename $file, $dst_file;

	if (defined $opt->{exec}) {
		my $cmd = $opt->{exec};
		my $param = $dst_file;
		$param =~ s/'/\\'/g;
		$cmd .= " '$param'" if $cmd !~ /\{\}/;
		$cmd =~ s/\{\}/'$param'/g;

		print "$cmd\n" if $opt->{verbose};
		system $cmd;
	}
}

sub show_files {
	my ($opt, $plan, $path) = @_;

	for my $file (sort {$plan->{$a} <=> $plan->{$b}} keys %$plan) {
		my $time = $plan->{$file};

		my $dst = ($opt->{gmt} ?
				strftime($path, gmtime $time) :
				strftime($path, localtime $time));

		print "$dst: $file\n";
	}
}

sub main {
	my ($opt, @files) = parse_args();

	# Configure input
	my $dir = defined $opt->{directory} ? $opt->{directory} : 'archives';
	my $absdir = abs_path($dir);

	my $path = defined $opt->{path} ? $opt->{path} : '%Y/%m/%d';
	@files = <./*> if @files == 0; # do not include '.*' unless dotglob is on

	# Make plan
	my $plan = {};

	for my $file (@files) {
		if (should_move($file, $absdir)) {
			my $time = get_time($opt, $file);

			if (!defined $opt->{older} or $time < $opt->{older}) {
				$plan->{$file} = $time;
			}
		}
	}

	if ($opt->{show}) {
		show_files($opt, $plan, $path);
		exit;
	}

	# Confirm
	my $num_files = scalar(keys %$plan);

	if ($num_files == 0) {
		print "No files to move\n" unless $opt->{force};
		exit 0;
	}

	unless ($opt->{force}) {
		print "Number of files to move: $num_files\n";
		print "Destination: $dir/$path\n";
		print "(Directory will be created)\n" unless -d $dir;

		if (defined $opt->{older}) {
			my $older_fmt = strftime('%F %T', $opt->{gmt} ?
					gmtime($opt->{older}) :
					localtime($opt->{older}));

			print "Older than: $older_fmt\n";
		}

		print "\n";
		print "Proceed? [yes/*no/show] ";
		STDOUT->flush;
		my $answer = <STDIN>;
		my $proceed = 0;

		if ($answer =~ /^y/i) {
			$proceed = 1;
		} elsif ($answer =~ /^s/i) {
			print "\n";
			show_files($opt, $plan, $path);
			print "\n";

			print "Proceed? [yes/*no] ";
			STDOUT->flush;
			$answer = <STDIN>;
			$proceed = ($answer =~ /^y/i);
		}

		unless ($proceed) {
			print "Canceled\n";
			exit 1;
		}
	}

	# Execute
	mkpath $dir if !-d $dir;

	for my $file (@files) {
		if (exists $plan->{$file}) {
			move_file($opt, $file, $plan->{$file}, $dir, $absdir, $path);
		}
	}
}

main();
